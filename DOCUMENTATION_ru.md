## Обзор проекта

Arcade Blocks — это современная аркадная игра в стиле разбивания блоков (в стиле Arkanoid), созданная на JavaFX и игровом движке FXGL. Игра содержит 116 уровней с битвами с боссами, бонусами, сюжетным режимом и поддержкой локализации (английский/русский).

**Главное приложение**: `com.arcadeblocks.ArcadeBlocksApp` (7700+ строк - центральная игровая логика)

**Технологический стек**:
- Java 21
- FXGL 21.1 игровой движок
- JavaFX 21 для UI
- VLC (через VLCJ 4.8.2) для видео битв с боссами
- SDL2 + SDL2_mixer (через JNA) для кроссплатформенного аудио
- SQLite для постоянного хранения данных
- Jackson для JSON данных уровней

## Требования к окружению

- **JDK**: Java 21 **с JavaFX** (рекомендуется Azul Zulu FX JDK 21 с уже включенным JavaFX). Установите `JAVA_HOME` на этот JDK.
- **Gradle Wrapper**: Используйте `./gradlew` (Unix/macOS) или `gradlew.bat` (Windows) из репозитория. При первом запуске wrapper автоматически скачает подходящую версию Gradle.
- **Права на исполнение**: При необходимости выполните `chmod +x gradlew` после клонирования на Unix/macOS.
- **JavaFX при другом JDK**: Если ваш JDK не содержит JavaFX, установите совместимый JavaFX SDK и добавьте `--module-path`/`--add-modules`, либо переключитесь на Azul Zulu FX.

## Команды сборки

### Разработка
```bash
# Собрать проект
./gradlew build

# Запустить приложение
./gradlew run

# Запустить тесты
./gradlew test

# Запустить конкретный тестовый класс
./gradlew test --tests com.arcadeblocks.utils.DatabaseIntegrityTest

# Очистить артефакты сборки
./gradlew clean
```

### Настройка Git LFS

Этот проект использует **Git LFS** (Large File Storage) для управления видеофайлами (заставки боссов). Видеофайлы хранятся отдельно и загружаются по требованию.

```bash
# Установить Git LFS (однократная настройка)
git lfs install

# Получить все LFS объекты (все ветки/ремоуты)
git lfs fetch --all

# Скачать LFS указатели для текущей ветки
git lfs pull

# Восстановить рабочие файлы из полученных объектов (при необходимости)
git lfs checkout

# Проверить статус LFS
git lfs status

# Список отслеживаемых LFS файлов
git lfs ls-files
```

**Важно**: Если вы клонировали репозиторий до установки Git LFS, видеофайлы будут файлами-указателями (небольшие текстовые файлы). Выполните `git lfs pull` для загрузки реальных видеофайлов.

**Отслеживаемые файлы**: Все файлы `*.mp4` в `src/main/resources/assets/textures/` управляются Git LFS (настроено в `.gitattributes`).

### Сборки для распространения

```bash
# Создать JAR с зависимостями
./gradlew jar

# Linux AppImage со встроенной JRE
./gradlew createLinuxAppImage

# Windows portable (без установщика)
./gradlew createWindowsPortable

# Windows установщик (.exe)
./gradlew createWindowsExe

# Скачать/настроить директории нативных библиотек
./gradlew downloadNativeLibraries
```

## Обзор архитектуры

### Основной игровой цикл (ArcadeBlocksApp.java)

Главный класс приложения расширяет `GameApplication` из FXGL. Это массивный класс (~7700 строк), который управляет:
- Управлением состоянием игры (меню, геймплей, битвы с боссами, сюжетные последовательности)
- Переходами между UI представлениями и их жизненным циклом
- Обработчиками обнаружения столкновений
- Логикой системы бонусов
- Инициализацией аудио/видео бэкендов
- Сохранением/загрузкой состояния игры

**Ключевые обязанности**:
- `initSettings()` - Конфигурация окна игры и движка
- `initGame()` - Создание платформы, мяча, загрузка уровней, инициализация стен
- `initPhysics()` - Регистрация обработчиков столкновений (мяч-блок, мяч-платформа, бонус-платформа, снаряд-блок и т.д.)
- `initUI()` - Настройка HUD, меню, оверлеев
- `onUpdate(double tpf)` - Игровая логика на каждый кадр (движение платформы, физика мяча, таймеры бонусов, ИИ боссов)

### Система сущностей (на базе FXGL)

**Типы сущностей** (`EntityType.java`):
- PADDLE, BALL, BRICK, BONUS, POWERUP, PROJECTILE, WALL, FLOOR, BOSS

**Фабрика сущностей** (`ArcadeBlocksFactory.java`):
- Методы с аннотацией `@Spawns` создают сущности с физикой, боксами столкновений и текстурами
- Платформа: кинематическое тело с restitution=1.0
- Мяч: динамическое тело с CCD (режим пули) для предотвращения прохождения сквозь объекты
- Блоки: статические коллизионные сущности со свойствами здоровья/цвета
- Бонусы: падающие капсулы с различными типами усилений

**Компоненты** (прикрепляются к сущностям):
- `Ball`, `Brick`, `Paddle`, `Bonus`, `Projectile`, `Boss` - компоненты игрового поведения

### Система уровней

**Уровни**: 116 JSON файлов в `src/main/resources/assets/levels/`
- Определяют расположение блоков (позицию, цвет, здоровье, очки)
- Уровни с боссами: 50, 100, 116
- Запасная процедурная генерация через `ProceduralLevelGenerator`

**LevelLoader**: Парсит JSON, создает блоки, применяет конфигурации бонусов для конкретных уровней

**LevelManager**: Обрабатывает прогрессию уровней, масштабирование сложности, переходы между главами

### Аудио система (SDL2AudioManager)

**Критично для совместимости с Linux**: JavaFX Media имеет проблемы в Linux, поэтому используется SDL2 через привязки JNA.

**Архитектура**:
- `SDL2AudioManager` - Основной аудио интерфейс, использующий SDL2_mixer
- `NativeLibraryLoader` - Определение платформы и извлечение нативных библиотек
- Библиотеки извлекаются во временную директорию во время выполнения из `src/main/resources/natives/{platform}/`

**Поддерживаемые платформы**:
- linux-x64, linux-aarch64
- windows-x64, windows-aarch64
- macos-x64, macos-aarch64

**Возможности**:
- Раздельное управление громкостью для музыки/звуковых эффектов
- Кэширование звуков
- Очередь последовательного воспроизведения

### Видео система (VLCJ)

**Используется для заставок битв с боссами** - поддержка JavaFX Media была удалена.

**Архитектура**:
- `VideoBackendFactory` - Создает бэкенд (VLC или Stub)
- `VlcjMediaBackend` - Реализация VLCJ 4
- `StubVideoBackend` - Запасной вариант при недоступности VLC
- `VlcContext` - Синглтон инициализации VLC
- `VideoResourceExtractor` - Извлекает видео файлы из ресурсов

**Плавная деградация**: Если VLC не найден, игра продолжается без видео.

### Архитектура UI

Все UI представления реализуют паттерны очистки для предотвращения утечек памяти:
- Интерфейс `SupportsCleanup` для представлений, требующих освобождения ресурсов
- Утилита `UINodeCleanup` для рекурсивной очистки
- Представления в `com.arcadeblocks.ui/`:
  - `MainMenuView` - Главное меню
  - `GameplayUIView` - Внутриигровой HUD (жизни, счет, уровень)
  - `PauseView` - Меню паузы
  - `SettingsView` - Настройки и управление
  - `ChapterStoryView` - Текст истории + видеоплеер
  - `GameOverView`, `LevelIntroView`, `CreditsView` и т.д.
  - Отладочные представления: `DebugMenuView`, `DebugLevelsView`, `DebugBonusesView`

**Жизненный цикл UI**:
1. Представление создано и добавлено в сцену
2. Анимации/таймеры запущены
3. При очистке: остановка анимаций, очистка ссылок, удаление со сцены
4. Освобождение видео/аудио ресурсов

### Постоянное хранение данных

**SaveManager**: Управляет прогрессом игры
- База данных SQLite: `arcade_blocks_save.db`
- Отслеживает: разблокированные уровни, рекорды, статус завершения
- Расположение: `~/.arcadeblocks/` (Linux/Mac) или `%APPDATA%/ArcadeBlocks/` (Windows)

**GameSnapshot**: Сериализуемое состояние игры для функции продолжения

**Настройки**: Хранятся в `arcade_blocks_settings.dat` (громкость аудио, управление, язык)

### Система бонусов/усилений

**Enum BonusType** определяет все бонусы:
- Положительные: EXTRA_LIFE, SHIELD, TURBO_BALL, EXPAND_PADDLE, PLASMA_CANNON, CALL_BALL и т.д.
- Отрицательные: SHRINK_PADDLE, CHAOS_BALLS, GHOST_PADDLE, FROZEN_PADDLE

**Конфигурация**:
- `BonusConfig` - Шансы выпадения и длительность по умолчанию
- `LevelConfig` - Переопределения бонусов для конкретных уровней (например, на уровне 100 невидимые капсулы)

**Механика**:
- Бонусы выпадают из разрушенных блоков (настраиваемый шанс)
- Столкновение с платформой активирует бонус
- Активные бонусы отслеживаются с таймерами в UI

### Локализация

**LocalizationManager**: Загружает property-файлы
- `src/main/resources/i18n/messages_en.properties`
- `src/main/resources/i18n/messages_ru.properties`

**Текст истории**: `StoryConfig` + `ChapterStoryData` для повествований на конкретных уровнях

## Важные конфигурации

### Игровые константы (GameConfig.java)

- **Игровой мир**: Всегда 1600x900 (внутреннее разрешение)
- **Размер окна**: Настраивается через `Resolution` (1600x900, 1920x1080)
- **Платформа**: 156x26px
- **Мяч**: радиус 10px
- **Блок**: 80x30px
- **Скорость мяча**: 650 единиц/сек
- **Скорость платформы**: 400 единиц/сек
- **Жизни**: 6 изначально
- **Всего уровней**: 116

### Настройка физики

Мяч использует **Непрерывное обнаружение столкновений (CCD)** для предотвращения прохождения сквозь блоки на высоких скоростях:
```java
body.setBullet(true); // в ArcadeBlocksFactory
```

Все столкновения используют `restitution=1.0` (идеальная упругость) для предсказуемых отскоков.

## Тестирование

Тесты используют JUnit 5 + Mockito + TestFX:
- `DatabaseIntegrityTest` - Валидация системы сохранения
- `ProjectileTest` - Поведение снарядов
- `MemoryLeakTests` - Обнаружение утечек сущностей
- `UITransitionMemoryLeakTests` - Валидация очистки UI
- `VlcWarningTest` - Проверки видео бэкенда

**TestFX** требует headless режим для CI. Запуск тестов с:
```bash
./gradlew test -Dtestfx.robot=glass -Dtestfx.headless=true
```

## Нативные библиотеки

**Критично для распространения**: Нативные библиотеки (SDL2, VLC) должны быть включены в поставку.

**Структура**:
```
src/main/resources/natives/
├── linux-x64/
├── linux-aarch64/
├── windows-x64/
├── windows-aarch64/
├── macos-x64/
└── macos-aarch64/
```

**Поведение во время выполнения**:
- `NativeLibraryLoader` определяет платформу
- Извлекает библиотеки во временную директорию
- Устанавливает `java.library.path`
- Удаляет временные файлы при завершении JVM

**Для сборок Windows**: VLC DLL требуются для воспроизведения видео. Если отсутствуют, игра использует запасной `StubVideoBackend`.

## Общие паттерны разработки

### Добавление нового бонуса

1. Добавьте enum в `BonusType` с названием текстуры
2. Обновите `BonusConfig` с шансом выпадения/длительностью
3. Реализуйте логику активации в `ArcadeBlocksApp.activateBonus()`
4. Добавьте деактивацию в `deactivateBonus()`
5. Обновите UI в `GameplayUIView` или `BonusTimerView`
6. Добавьте ключи локализации в `messages_*.properties`

### Добавление нового уровня

1. Создайте `levelXXX.json` в `src/main/resources/assets/levels/`
2. Определите расположение блоков с позициями, цветами, здоровьем, очками
3. Опционально: Добавьте конфигурацию бонусов для конкретного уровня в `LevelConfig`
4. Опционально: Добавьте текст истории в `StoryConfig`

### Создание нового босса

1. Расширьте компонент `Boss` в `com.arcadeblocks.bosses/`
2. Реализуйте `onUpdate()` для паттернов ИИ
3. Добавьте логику стрельбы снарядами
4. Создайте сущность босса в JSON уровня или программно
5. Добавьте видео босса в `src/main/resources/assets/videos/`

## Заметки об управлении памятью

Игра имеет строгие протоколы очистки для предотвращения утечек памяти во время долгих игровых сессий:

**UI представления**: Должны реализовывать `SupportsCleanup` и вызывать `UINodeCleanup.cleanup(node)`
**Сущности**: Удалять из мира с помощью `entity.removeFromWorld()`
**Таймеры**: Всегда очищать с помощью `timer.cancel()` или `timer.clear()`
**Анимации**: Останавливать и устанавливать в null
**Аудио**: Освобождать потоки с помощью `audioManager.cleanup()`

## Отладка

**Меню отладки**: Доступно через `DebugMenuView` (обычно привязано к специальной комбинации клавиш)
- Выбор уровня: `DebugLevelsView`
- Тестирование бонусов: `DebugBonusesView`
- Активация любого бонуса или переход на любой уровень

**Логирование в консоль**: Использует логгер FXGL (выводит в директорию `logs/`)

## Исключения файлов

- `SimpleApp.java` - Исключен из компиляции (build.gradle строка 110)
- VLC DLL ранее включались в `src/main/resources/natives/windows-x64/` - теперь удалены, используется системный VLC или извлечение во время выполнения
